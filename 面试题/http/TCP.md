# TCP协议

UDP 和 TCP 的区别是什么？
1. TCP面向有连接
2. TCP协议只是数据报文的搬运工，保证有序且不丢失的传递
3. TCP有流量控制算法，相对UDP来说比较繁重

头部：
    Sequence number:该序号保证TCP传输的报文都是有序的，接收端就可以通过顺序拼接报文
    Acknowledgement Number:表示接收端期望接受的下一个字节的编码，同时也表示一个序号的数据已经接收到了
    Window Size:窗口大小表示还能拿个接受多少字节的数据，用于流量控制

# TCP三次握手
1. 客户端向服务端发送请求报文，客户端会进入SYN-SENT状态
2. 服务端接收到这个请求后如果同意，则发送一个应答发送后便进入SYN-RECEIVED 状态
3. 客户端接收到统一的应答后，再向服务端发送一个确认报文，客户端进入ESTABLISHED状态，服务端也进入ESTABLISHED状态，此时连接建立成功

# 为什么TCP建立连接需要三次握手，明明两次就可以建立连接
    两次握手：当客户端放一个连接请求A，因为网络原因A请求超时了，因为TCP有超时重传机制，就会重新发送连接请求B，服务端接收到B后进行应答，之后数据传递完释放连接
    假设此时A在两端关闭后又到达了服务端，那么此时服务端就会认为客户端用需要建立连接，于是去响应并进入ESTABLISHED状态，但是客户端已经CLOSED状态，服务端就会一直等，造成资源浪费

# 四次挥手
1. 客户端认为数据发送完成，向服务端发送释放连接的请求
2. 服务端接收到释放连接的请求后，告诉应用层该释放TCP连接，然后向客户端发送ACK包，并进入CLOSE_WAIT状态，表示不再接收客户端的数据了，但是因为TCP是双向连接，服务端还能向客户端发送数据
3. 如果服务端此时还有没法玩的数据就会继续发送，完毕后就会向客户端发送连接释放请求，自己进入LAST-ACK状态
4. 客户端接收到服务端的释放请求，向服务端确认应答，自己进入TIME-WAIT状态2毫秒（MS）后就进入CLOSED状态，服务端在接收到这个应答后也进入CLOSED状态

# 为什么客户端要进入TIME-WAIT状态，等待2MS时间后才进入CLOESD状态？
为了保证服务端能够接收到客户端的确认应答，如果客户端确认应答后直接进入CLOSED状态，万一因为网络问题导致应答没有被服务端接收到，那么会造成数据浪费

# 浏览器渲染流程
如果要讲从输入 url 到页面加载发生了什么,那怕是没完没了了…这里我们只谈谈浏览器渲染的流程。

解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件
CSS 文件下载完成,解析 CSS 文件成树形的数据结构,然后结合 DOM 树合并成 RenderObject 树
布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算
绘制 RenderObject 树 （paint）,绘制页面的像素信息
浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面

